
//
// This source file is part of appleseed.
// Visit http://appleseedhq.net/ for additional information and resources.
//
// This software is released under the MIT license.
//
// Copyright (c) 2014 The masked shader writer, The appleseedhq Organization
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

#include "mayautils.h"

#define MAXENTRIES 10
#define RAMPCOLORIN vector color0=0[[string compAttrArrayPath="colorEntryList.color"]], \
                    vector color1=0[[string compAttrArrayPath="colorEntryList.color"]], \
                    vector color2=0[[string compAttrArrayPath="colorEntryList.color"]], \
                    vector color3=0[[string compAttrArrayPath="colorEntryList.color"]], \
                    vector color4=0[[string compAttrArrayPath="colorEntryList.color"]], \
                    vector color5=0[[string compAttrArrayPath="colorEntryList.color"]], \
                    vector color6=0[[string compAttrArrayPath="colorEntryList.color"]], \
                    vector color7=0[[string compAttrArrayPath="colorEntryList.color"]], \
                    vector color8=0[[string compAttrArrayPath="colorEntryList.color"]], \
                    vector color9=0[[string compAttrArrayPath="colorEntryList.color"]]
#define RAMPPOSIN float position0=-1[[string compAttrArrayPath="colorEntryList.position"]], \
                  float position1=-1[[string compAttrArrayPath="colorEntryList.position"]], \
                  float position2=-1[[string compAttrArrayPath="colorEntryList.position"]], \
                  float position3=-1[[string compAttrArrayPath="colorEntryList.position"]], \
                  float position4=-1[[string compAttrArrayPath="colorEntryList.position"]], \
                  float position5=-1[[string compAttrArrayPath="colorEntryList.position"]], \
                  float position6=-1[[string compAttrArrayPath="colorEntryList.position"]], \
                  float position7=-1[[string compAttrArrayPath="colorEntryList.position"]], \
                  float position8=-1[[string compAttrArrayPath="colorEntryList.position"]], \
                  float position9=-1[[string compAttrArrayPath="colorEntryList.position"]]
                  
color interpolateColors(color firstColor, color secondColor, float first, float second, float value, int interpolation)
{
    color outColor = 0;

    if (value >= 1.0)
    {
        outColor = secondColor;
    }
    if (value <= 0.0)
    {
        outColor = firstColor;
    }
    float diff = second - first;
    if (diff == 0.0 )
    {
        outColor = firstColor;
    }
    else
    {    
        if (interpolation == 0) // none
        {
            outColor = firstColor;
        }
        if (interpolation == 1) // linear
        {
            float per = (value - first) / diff;
            outColor = firstColor  * (1.0 - per) + secondColor* per;            
        }
        if (interpolation == 2) // exp up
        {
            float per = (value - first) / diff;
            per *= per;
            outColor = firstColor * (1.0 - per) + secondColor * per;
        }
        if (interpolation == 3) // exp down
        {
            float per = (value - first) / diff;
            per *= per;
            per = 1.0 - per;
            outColor = firstColor * (1.0 - per) + secondColor * per;
        }
        if (interpolation == 4) // smooth
        {
            float per = (value - first) / diff;
            per = (cos((per + 1.0) * M_PI) + 1.0) * 0.5;
            outColor = firstColor * (1.0 - per) + secondColor * per;
        }
        if (interpolation == 5) // bump
        {
            float per = (value - first) / diff;
            float per2;
            color diffCol = secondColor - firstColor;
            
            if ((diffCol[0]+diffCol[1]+diffCol[2]) > 0.0)
                per2 = sin(per * M_PI_2);
            else
                per2 = sin((per - 1.0) * M_PI_2) + 1.0;

            outColor[0] = per2 * (secondColor[0] - firstColor[0]) + firstColor[0];
            outColor[1] = per2 * (secondColor[1] - firstColor[1]) + firstColor[1];
            outColor[2] = per2 * (secondColor[2] - firstColor[2]) + firstColor[2];
        }        
        if (interpolation == 6) // spike
        {
            float per = (value - first) / diff;
            float per2;
            color diffCol = secondColor - firstColor;
            
            if((diffCol[0]+diffCol[1]+diffCol[2]) < 0.0)
                per2 = sin(per * M_PI_2);
            else
                per2 = sin((per - 1.0) * M_PI_2) + 1.0;

            outColor[0] = per2 * (secondColor[0] - firstColor[0]) + firstColor[0];
            outColor[1] = per2 * (secondColor[1] - firstColor[1]) + firstColor[1];
            outColor[2] = per2 * (secondColor[2] - firstColor[2]) + firstColor[2];
        }        
    }    
    return outColor;
}

color getColorsAtPos(color col[], float pos[], int interpolation, float value)
{
    float first=-1.0, second=2.0;
    color firstColor = 0;
    color secondColor = 0;
    float pMin = 2.0;
    int iMin = -1;
    for (int i = 0; i < MAXENTRIES; i++)
    {
        float p = pos[i];
        if (p < 0)
            continue;
        p = clamp(p, 0.0, 1.0);
        if (p < pMin)
        {
            pMin = p;
            iMin = i;
        }
        if ((p <= value)&&(p > first))
        {
            first = p;
            firstColor = col[i];
        }
        if ((p >= value)&&(p < second))
        {
            second = p;
            secondColor = col[i];
        }    
    }
    if (first < pMin)
    {
        first = pMin;
        firstColor = col[iMin];
    }
    return(interpolateColors(firstColor, secondColor, first, second, value, interpolation));
}

shader ramp
(
    RAMPCOLORIN,
    RAMPPOSIN,
    int numEntries = 0,
    int type = 0,
    int interpolation = 0,
    vector uvCoord = 0,
    float uCoord = 0.0,
    float vCoord = 0.0,
    MAYA_COLORBALANCE,
    MAYA_DEFAULT_OUTPUT
)
{
    outColor = vector(0,0,0);

    float s = u;
    float t = v;

    // here we have a strange thing. If a ramp node is connected to the uvCoord, the attribute is called
    // uvCoord. But if we have a connection to on component, the connection is called uCoord, or vCoord
    if (isconnected(uvCoord))
    {
        s = uvCoord[0];
        t = uvCoord[1];
    }
    else
    {
        if (isconnected(uCoord))
        s = uCoord;
        if (isconnected(vCoord))
            t = vCoord;            
    }

    s = (s > 1.0 || s < 0.0) ? s - floor(s) : s;
    t = (t > 1.0 || t < 0.0) ? t - floor(t) : t;

    float pos[MAXENTRIES];
    color col[MAXENTRIES];

    col[0] = color(color0);
    col[1] = color(color1);
    col[2] = color(color2);
    col[3] = color(color3);
    col[4] = color(color4);
    col[5] = color(color5);
    col[6] = color(color6);
    col[7] = color(color7);
    col[8] = color(color8);
    col[9] = color(color9);

    pos[0] = position0;
    pos[1] = position1;
    pos[2] = position2;
    pos[3] = position3;
    pos[4] = position4;
    pos[5] = position5;
    pos[6] = position6;
    pos[7] = position7;
    pos[8] = position8;
    pos[9] = position9;

    if (numEntries == 0)
    {
        outColor = vector(0,0,0);
    }

    if (numEntries == 1)
    {
        outColor = vector(color0);
    }

    if (numEntries > 1)
    {
        if (type == 0) // v-ramp
        {
            float value = t;
            outColor = vector(getColorsAtPos(col, pos, interpolation, value)); 
        }
        if (type == 1) // u-ramp
        {
            float value = s;
            outColor = vector(getColorsAtPos(col, pos, interpolation, value)); 
        }
        if (type == 2) // diagonal-ramp
        {
            float value = (s + t) * 0.5;
            outColor = vector(getColorsAtPos(col, pos, interpolation, value)); 
        }
        if (type == 3) // radial-ramp
        {
            float value = 0;
            float ss = s - 0.5;
            float tt = t - 0.5;
            if((ss == 0.0) && (tt == 0.0))
                value = 0.0;
            else
                value = atan2(ss, tt) / M_2PI + 0.5;
            outColor = vector(getColorsAtPos(col, pos, interpolation, value)); 
        }
        if (type == 4) // circular-ramp
        {
            float value = 0;
            float ss = (s - 0.5) * 1.414;
            float tt = (t - 0.5) * 1.414;
            value = ss * ss + tt * tt;
            if (value > 0)
                value = sqrt(value);
            outColor = vector(getColorsAtPos(col, pos, interpolation, value)); 
        }
        if (type == 5) // box-ramp
        {
            float value = 0, ss = 0, tt = 0;
            ss = abs(s - 0.5);
            tt = abs(t - 0.5);
            if (ss > tt)
                value = ss * 2.0;
            else
                value = tt * 2.0;        
            outColor = vector(getColorsAtPos(col, pos, interpolation, value)); 
        }
        if (type == 6) // uv-ramp
        {
            float value = 0, ss = 0, tt = 0;
            ss = abs(s - 0.5) * 2.0;
            tt = abs(t - 0.5) * 2.0;
            vector c1 = vector(getColorsAtPos(col, pos, interpolation, tt)); 
            vector c2 = vector(getColorsAtPos(col, pos, interpolation, ss)); 
            outColor[0] = c1[0] * c2[0];
            outColor[1] = c1[1] * c2[1];
            outColor[2] = c1[2] * c2[2];
        }
        if (type == 7) // 4 corner-ramp
        {
            float value = 0, ss = 0, tt = 0;
            color c1 = col[0];
            float w1 = (1.0 - s) * (1.0 - t);
            outColor[0] = c1[0] * w1;
            outColor[1] = c1[1] * w1;
            outColor[2] = c1[2] * w1;

            if (numEntries > 1) 
            {
              color c1 = col[1];
              float w1 = s * (1.0 - t);
              outColor[0] += c1[0] * w1;
              outColor[1] += c1[1] * w1;
              outColor[2] += c1[2] * w1;
            }
            if (numEntries > 2) 
            {
              color c1 = col[2];
              float w1 = (1.0 - s) * t;
              outColor[0] += c1[0] * w1;
              outColor[1] += c1[1] * w1;
              outColor[2] += c1[2] * w1;
            }
            if (numEntries > 3) 
            {
              color c1 = col[3];
              float w1 = s * t;
              outColor[0] += c1[0] * w1;
              outColor[1] += c1[1] * w1;
              outColor[2] += c1[2] * w1;
            }
        }
        if (type == 8) // tartan-ramp
        {
            float value = 0, ss = 0, tt = 0;
            ss = abs(s - 0.5) * 2.0;
            tt = abs(t - 0.5) * 2.0;
            vector c1 = vector(getColorsAtPos(col, pos, interpolation, tt)); 
            vector c2 = vector(getColorsAtPos(col, pos, interpolation, ss)); 
            outColor[0] = (c1[0] + c2[0]) * 0.5;
            outColor[1] = (c1[1] + c2[1]) * 0.5;
            outColor[2] = (c1[2] + c2[2]) * 0.5;            
        }
    }

    outColor = colorBalance(outColor, colorGain, colorOffset);
    if (alphaIsLuminance == 1)
        outAlpha = luminance(color(outColor));
}
